ECMAScript 新特性



## ECMAScript 概述

1. ECMAScript也是一门脚本语言，通常看作是 JavaScript 的标准化规范，实际上是 JavaScript 是 ECMAScript 的扩展语言

2. ECMAScript只提供了基本的语法，约定了代码该如何编写，比如怎么定义变量和函数，怎么写循环语句之类的，并不能直接用于开发

3. JavaScript 实现了 ECMAScript 定义的标准，以及一些扩展，使的语言能在浏览器运行操作BOM，DOM等，在node环境能够操作数据、文件

4. 在浏览器运行，JavaScript 实际上是 ECMAScript 本身，结合浏览器提供的APIs实现功能

   ![JavaScript在浏览器上运行示意图](E:\前端开发工程师的学习之旅\前端进阶学习代码\模块一\任务一 ECMAScript新特性\notes\images\pic_01.png)

   在node环境下，JavaScript 实际上是 ECMAScript 本身，结合node环境提供的APIs实现功能

   ![JavaScript在node环境下的运行示意图](E:\前端开发工程师的学习之旅\前端进阶学习代码\模块一\任务一 ECMAScript新特性\notes\images\pic_02.png)

   

   > Javascript 语言本身指的就是ECMAScript



## ES2015 / ES6 概述

最新ECMAScript标准的代表版本，详细新增内容可查看：

<http://www.ecma-international.org/ecma-262/6.0/>

新增内容大致可分为四大类

* 解决原有语法上的一些问题或者不足（例如：let，const）
* 对原有语法进行增强（例如：解构，模板字符串，展开）
* 全新的对象、全新的方法、全新的功能（例如：promise，async await）
* 全新的数据类型和数据结构（例如：symbol，map，set）



> 准备工作：在node环境下运行代码，可以安装nodemon插件以便实时编译修改后的代码，使用方法和node一样



## ES2015 let与块级作用域

### 作用域 

概述： 某个成员能起作用的范围

* 全局作用域
* 函数作用域
* 块级作用域（ES2015新增）

### 块级作用域

一对花括号包裹起来的范围，例如 if 语句和 for 语句

```javascript
if(true){
    console.log('Hello World!')
}

for(let i = 0; i < 10; i++){
    console.log('Hello World!')
}
```



> 在 ES2015 之前没有块级作用域的概念，块内定义的变量可在外部调用，容易产生问题



经典案例一：

```javascript
for(var i = 0; i < 3; i++){
    for(var i = 0; i < 3; i++){
        console.log(i)
    }
}
// 结果：只循环3次
// 原因：因为都是定义的全局变量，var不受块级作用域的影响，所以内部循环定义的变量覆盖了之前定义的，所以当内部循环完成之后，i = 3, 外部循环条件不满足，结束循环

// 解决办法：将 var 改成 let，使变量受块级作用域的约束(只需要改内部循环的变量定义)
for(let i = 0; i < 3; i++){
    for(let i = 0; i < 3; i++){
        console.log(i)
    }
}
```

经典案例二：

```javascript
// 用数组模拟web元素
var elements = [{}, {}, {}]
for (var i = 0; i < elements.length; i++){
    elements[i].onclick = function () {
        console.log(i)
    }
}
elements[0].onclick() //3
elements[1].onclick() //3
elements[2].onclick() //3

// 结果：执行结果均为3
// 原因：虽然console.log()处于函数作用域内，但是调用的i始终都是定义在全局作用域下变量i，所以当循环结束后，此时i被累计到了3，之后调用函数的时候i始终为3

// 解决办法
// 方法一：使用闭包解决
// 原理：用函数作用域摆脱全局作用域的影响，将i保存到函数作用域内
for (var i = 0; i < elements.length; i++){
    elements[i].onclick = (function (i) {
        return function () {
            console.log(i)
        }
    })(i)
}
// 分析：此时console.log()调用的i是函数的参数i，当循环开始的时候，函数立即执行，并将全局变量i的值通过参数传进函数作用域内，此时
// 当 i = 0 时，onclick = funtion(){ console.log(0) /*i已被赋值成0*/ }，
// 当 i = 1 时，onclick = funtion(){ console.log(1) /*i已被赋值成1*/ }，
// 当 i = 2 时，onclick = funtion(){ console.log(2) /*i已被赋值成2*/ }，
// 所以循环后调用onclick函数打印出来的数据和全局变量i并没有关系了

// 方法二：使用ES2015新增的let定义变量
// 原理：用块级作用域替换全局作用域
for (let i = 0; i < elements.length; i++){
    elements[i].onclick = function () {
        console.log(i)
    }
}
// 分析：当onclick调用的时候，console.log()在函数作用域内找不到i，所以向上级作用域内查找，（es2015有块级作用域），上级作用域为块级作用域，当用var的时候，块级作用域仍找不到变量i，将会再向上级作用域找到全局变量i，当用let的时候会在块级作用域内找到变量i
// for循环每次开始的时候，当用var定义时，因为变量提升的关系，所以每次循环都是给i重新赋值，当用let定义时，每次执行代码块的时候，都会重新定义一个新的i并赋值
// 所以当onclick被调用的时候，会将整个代码块压入栈中执行，即执行代码块
/* {
	let i = 1
    funtion(){
        console.log(i)
    }
} */
// 应该也可理解为onclik调用时，此时开始执行上下文，会先提取方法内的变量进行赋值，找到上级作用域内的变量i
// 理清楚的关键点在于，for循环在var定义变量的时候，每次循环都是给变量重新赋值，而用let定义变量的时候，每次循环都重新定义了新的变量i在块级作用域内，相互独立
```



## ES2015 const

const 比 let 多了个只读的特性，无法被重新赋值

```javascript
const name = '张三'
name = '李四' //报错，const定义的变量不能被重新赋值
```

但是并不是不允许被修改成员对象，只是不允许修改在内存中的内存地址

```javascript
const obj = {}
obj.name = '张三' // 允许，因为并未修改对象的内存地址，只是修改了内存地址内的数据内容

obj = {} // 不允许，因为会修改对象的内存地址

```

> 最佳实践：不用 var，默认使用 const，需要修改变量值的时候使用 let



## ES2015 数组的解构

解构的定义

```javascript
const arr = [100, 200, 300]
const [foo, bar, baz] = arr // 定义变量数组，用于存放需要解构的数组解构出来的数据
console.log(foo)
```

若是需要单独解构某个位置的数据，只需要将前面位置不定义变量即可，但是仍要保留逗号

```javascript
const [, , baz] = arr
console.log(baz)
```

使用rest运算符可以解构剩余数组的元素

```javascript
const [foo, ...rest] = arr
console.log(rest) // [200, 300]

// ps: 只能在解构成员的最后一位使用
```

解构的成员数量可以小于被解构数组的长度，会按照从前到后的顺序提取

如果大于被解构数组的长度，则多出来的变量值为undefined

解构可以赋默认值，若没提取到数据，会赋予默认值

```javascript
const [foo] = arr
console.log(foo) // 100

const [foo, bar, baz, more] = arr
console.log(more) // undefined

const [foo, bar, baz, more = 'default'] = arr
console.log(more) // default
```

应用案例：

```javascript
// 将字符串拆分成数组并解构
const path = '/foo/bar/baz'
const [, rootdir] = path.split('/')
console.log(rootdir)
```



## ES2015 对象的解构

和数组解构不同的是，对象的解构并不能以成员的位置来逐个解构，因为对象并不像数组那样有下标表示次序，所以对象的解构应该要用匹配对象的变量

```javascript
const obj = {name: '张三'， age: 20}
const {name, age} = obj
console.log(name) // 张三
console.log(age) // 20
```

如果定义了和对象的属性名相同的变量，则会报错，需要给解构的对象重命名

```javascript
const name = '李四'
const {name: objName, age} = obj
```

如果此时需要赋默认值的话，只需要在重命名后赋值就可以了

```javascript
const {name: objName = '李四', age} = obj
```

应用案例：

```javascript
// 为了简化代码
const {log} = console
log('Hello')
log('World!')
```



## ES2015 模板字符串

模板字符串是以一组反引号``构成的

```javascript
const str = `Hello World!`
// 模板字符串内支持转义符
const str2 = `Hello \`World!\``
console.log(str2) // Hello `World!`
```

模板字符串支持直接换行

```javascript
const str = `Hello

World!`

console.log(str)
/*
Hello

World!
*/
```

模板字符串以插值表达式的方式嵌入变量

在插值表达式内支持javascript代码，并将返回的数据显示出来

```javascript
const name = '张三'
const str = `Hello, ${name} --- ${1 + 2}`
```



## ES2015 带标签的模板字符串

模板字符串的高级用法，在模板字符串前添加标签，标签为特殊的函数，添加后会调用该函数，并返回函数返回的数据

```javascript
const name = '张三'
const str = console.log`Hello，${name}` // ['Hello, ', '']张三
```

函数有多个参数，第一个参数为模板字符串内静态数据组成的数组（数组的内容相当于用split()以插值表达式为匹配规则拆分出来的数据），剩余的参数为模板字符串内表达式

```javascript
const name = '张三'
funtion tag (strings, name) {
	console.log(strings)
	console.log(name)
    return strings[0] + name + strings[1]
}
const str = tag`Hello, ${name}` // Hello, 张三
```



## ES2015 字符串的扩展方法

### startsWith()

用于判断字符串是否以某个字符串开头，返回boolean

```javascript
const message = 'Error: foo is not defined.'
console.log(message.startsWith('Error')) // true
```

### endsWith()

用于判断字符串是否以某个字符串结尾，返回boolean

```javascript
const message = 'Error: foo is not defined.'
console.log(message.endsWith('.')) // true
```

### includes()

用于判断字符串是否包含某个字符串，返回boolean

```javascript
const message = 'Error: foo is not defined.'
console.log(message.includes('foo')) // true
```



## ES2015 参数默认值

在ES2015之前设置参数默认值需要在函数体内判断参数是否为undefined

```javascript
function foo (enable) {
	enable = enable === undefined ? true : enable
    // 这里不能使用短路运算 enable = enable || true
    // 因为传入参数为false时，还是使用的默认值true
    console.log(enable)
}
foo()
```

在ES2015之后可以直接给参数赋值，但是有多个参数的话，有默认值的参数必须放到最后面，为防止调用的时候如果需要使用默认值导致的传参问题

```javascript
function foo (bar, enable = true){
	console.log(enable)
}
foo()
```



## ES2015 剩余参数

在ES2015 之前，可以用 arguments 对象接收所有的参数

```javascript
function foo (){
	console.log(arguments)
}
foo(1, 2, 3, 4) // [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4 } 伪数组
```

ES2015之后可以使用 ... 表示剩余参数

```
function foo (foo, ...args){
	console.log(args)
}
foo(1, 2, 3, 4) // [2, 3, 4]
```



## ES2015 展开数组

在 ES2015 之前要打印数组中的所有数据比较麻烦

最笨的方法

```javascript
const arr = ['foo', 'bar', 'baz']
console.log(
	arr[0],
	arr[1],
	arr[2]
)
// 这个在未知数量的数组是行不通的
```

使用apply方法

```javascript
console.log.apply(console, arr)

// apply方法执行的时候，会把传入的数组参数解构出来并传入到对象上执行
// 以上语句相当于执行了
// console.log('foo', 'bar', 'baz') 并顺便让console继承了console.log的属性和方法
```

在 ES2015 后使用展开运算符

```
console.log(...arr)
```



## ES2015 箭头函数与this

箭头函数的写法

```javascript
const inc = n => n + 1
// 箭头函数左边如果只有一个参数的话，可以省略小括号
// 箭头函数右边如果只有一条语句的话，可以省略花括号，并且默认返回
```

箭头函数不会改变this的指向

```javascript
const person = {
	name: '张三',
    sayHi: function (){
        console.log(this.name)
    }
}
person.sayHi() // 张三 普通函数的this会指向调用它的对象
-----------------------------------------------------
const person = {
	name: '张三',
    sayHi: () => {
        console.log(this.name)
    }
}
person.sayHi() // undefined 箭头函数不改变this指向，所以此时this指向全局作用域，在web环境下是指向document，在node环境下是指向{}

// 扩展：
const person = {
	name: '张三',
    sayHi: () => {
        console.log(this.name)
    },
    sayHiSync: function () {
        setTime(function(){
            console.log(this.name)
        }, 1000)
    }
}
person.sayHiSync() // undefined 普通函数是记住谁调用this就指向谁，此时计时器执行的函数时全局对象在调用

const person = {
	name: '张三',
    sayHi: () => {
        console.log(this.name)
    },
    sayHiSync: function () {
        setTime(() => {
            console.log(this.name)
        }, 1000)
    }
}
person.sayHiSync() // 张三 箭头函数记住this指向不变，所以去上级找调用的对象
```



## ES2015 对象字面量的增强

对象属性的值用变量表示的时候，如果和属性名相同可以简写

```javascript
const name = '张三'
const obj = {
    name
}
```

对象的属性值时方法时，可以简写

```javascript
const obj = {
	// method: function () {
	// 	 console.log('张三')
	// }
    method () {
        console.log('张三')
	}
}
```

对象的属性名可以是表达式的返回值，用 [表达式] 表示

```javascript
const obj = {
	[Math.random()]: '张三',
    [1 + 2]: '李四'
}
```



## ES2015 Object.assign

将多个源对象中的属性复制到一个目标对象中

```javascript
const source1 = {
	a: '123',
	b: '123'
}
const source2 = {
	c: '456',
	d: '456'
}
const target = {
	a: '666',
	c: '233'
}

const result = Object.assign(target, source1, source2) // 可以传入任意多的源对象

console.log(result) // {a: '123', b: '123', c: '456', d: '456'}
console.log(result === target) // ture 
```

应用案例：

```javascript
function func (obj) {
    obj.name = '李四'
    console.log(obj)
}
const obj = {name: '张三'}
func(obj) // {name: '李四'}
console.log(obj) // {name: '李四'}
// 运行结果一样，因为直接修改对象的属性会影响源对象的属性
-----------------------------------------------------
function func (obj) {
    const funcObj = Object.assign({}, obj)
    funcObj.name = '李四'
    console.log(funcObj)
}
const obj = {name: '张三'}
func(obj) // {name: '李四'}
console.log(obj) // {name: '张三'}
// 将对象复制到空对象再进行修改
```



## ES2015 Object.is

判断两个值是否相等

```javascript
// 和 === 区别在于以下两个判断不同
console.log(+0 === -0) // true
console.log(Object.is(+0, -0)) // false

console.log(NaN === NaN)) // false
console.log(Object.is(NaN, NaN)) // true
```

> 一般情况下还是使用 === 比较好



## ES2015 Proxy

Proxy 用于访问对象读写时候监听操作

```javascript
const person = {
	name: '张三',
	age: 20
}
const personProxy = new Proxy(person, {
	get (target, property) {
        // target 监听的目标对象， property 要获取的属性
		console.log(target, property)
        return target[property]
	},
	set (target, property, value) {
        // target 监听的目标对象， property 要设置的属性， value 要设置的属性值
		console.log(target, property, value)
        return target[property] = value
	}
})
personProxy.gender = '男'
console.log(personProxy.name) // 张三
console.log(personProxy.gender) // 男
```



## ES2015 Proxy 对比 defineProperty

Proxy比defineProperty拥有更多的优势

1. Proxy 能监视到更多的对象操作，defineProperty只能监视对象的读写

   ```javascript
   const person = {
   	name: '张三',
   	age: 20
   }
   // 监听删除对象属性的操作
   const personProxy = new Proxy(person, {
   	deleteProperty (target, property) {
           console.log('delete', property)
           delete target[property]
       }
   })
   delete personProxy.age // 删除对象属性操作
   console.log(person) // 会影响到源对象
   ```

   ![Proxy可以监视到的对象操作](E:\前端开发工程师的学习之旅\前端进阶学习代码\模块一\任务一 ECMAScript新特性\notes\images\pic_03.png)

2. Proxy 能更好的监视数组对象的操作

   ```javascript
   const list = []
   const listProxy = new Proxy(list, {
   	set (target, property, value){
   		console.log('set', property, value)
   		target[property] = value
   		return true
   	}
   })
   listProxy.push(100)
   ```

3. Proxy 是以非侵入方式监管对象的读写

   Proxy 可以很方便的监视已经定义好的对象的操作

   而defineProperty必须通过特定的方式，单独定义需要监视的属性，对于定义好的对象，需要做额外的操作

   ```javascript
   // define 要麻烦的多
   const person = {}
   Object.defineProperty(person, 'name', {
   	get () {
   		console.log('name 被访问')
   		return person._name
   	},
   	set (value) {
   		console.log('name 被设置')
   		return person._name = value
   	}
   })
   Object.defineProperty(person, 'age', {
   	get () {
   		console.log('age 被访问')
   		return person._age
   	},
   	set (value) {
   		console.log('age 被设置')
   		return person._age = value
   	}
   })
   person.name = '张三'
   console.log(person)
   ```



## ES2015 Reflect

Reflect 内部封装了一系列对对象的底层操作，是一个静态类，不能通过new 方式构建实例对象，只能调用静态类的静态方法，一共十三个方法，方法名和Proxy的一致，Reflect 成员方法就是Proxy处理对象的默认实现

```javascript
const obj = {
	name: '张三',
	age: 20
}
// 未定义监听任何方法，但是行为和返回Reflect是一致的
const objProxy = new Proxy(obj, {

})
console.log(objProxy.name) // 张三 仍能正确返回

const objProxy = new Proxy(obj, {
	get (target, property) {
        return Reflect.get(target, property)
    }
})
console.log(objProxy.name) // 张三
```

统一提供一套用于操作对象的API

```javascript
const obj = {
	name: '张三',
	age: 20
}
console.log(Reflect.has(obj, 'name'))
console.log(Reflect.deleteProperty(obj, 'age'))
console.log(Reflect.ownKeys(obj))
```



## ES2015 Promise

一种更优的异步编程解决方案，解决了传统异步编程中回调函数嵌套过深的问题



## ES2015 class 类

```javascript
// ES2015之前通过定义函数，以及函数的原型对象实现类型
function Person (name) {
    this.name = name
}
Person.prototype.say = function () {
    console.log('Hello World!')
}

// ES2015之后可以用class类实现
class Person {
    constructor (name) {
        this.name = name
    }
    say () {
        console.log(this.name)
    }
}
const p = new Person('张三')
p.say()
```



## ES2015 静态方法

类型方法一般分为实例方法和静态方法

实例方法是通过new操作创建新的实例对象，在调用方法

而静态方法是通过类型本身去调用方法

ES2015 中新增添加静态成员的 static 关键词

```javascript
class Person {
    constructor (name) {
        this.name = name
    }
    say () {
        console.log(this.name)
    }
    // 创建实例对象的静态方法
    static create (name) {
        console.log(this) // Person，因为静态类是挂载在类型上的，所以this指向类型，而不是实例对象
        return new Person(name)
    }
}
const p = Person.create('张三')
p.say()
```



## ES2015 类的继承

ES2015 使用了新的关键词 extends 用于继承类

```javascript
class Person {
    constructor (name) {
        this.name = name
    }
    say () {
        console.log(`My name is ${this.name}`)
    }
}
class Student extends Person {
    constructor (name, number) {
        super(name) // super 始终指向父类，即调用父类的构造函数
        this.number = number
    }
    hello () {
        super.say() // super对象
        console.log(`My number is ${this.number}`)
    }
}
const stu = new Student('张三', 12)
stu.hello()
```



## ES2015 Set

Set，全新的数据结构，是一个集合，Set内部的成员不允许重复

```javascript
const s = new Set()
// Set可以通过add方法添加数据，并且返回集合对象本身，所以可以链式调用
s.add(1).add(2).add(3).add(4).add(1)
console.log(s) // Set {1, 2, 3, 4} 如果添加了重复的数据，会被忽略

// Set可以通过forEach() 或者 for...of 遍历集合
s.forEach(i => console.log(i)) // 1 2 3 4
for (let i of s){
    console.log(i)
} // 1 2 3 4

// 可以通过size属性获取集合的长度
console.log(s.size) // 4

console.log(s.has(100)) // false has 判断集合是否含有某个特定的值

console.log(s.delete(3)) // true delete方法可以删除集合中特定的值，并返回true
console.log(s) // Set {1, 2, 4}

s.clear() // 清空集合内所有值
console.log(s) // Set {}
```

应用案例：

```javascript
// 可以很方便的给数组去重
const arr = [1, 2, 1, 3, 2, 4]
const result = new Set(arr)
console.log(result) // Set {1, 2, 3, 4}

// 若要返回数组, 可以通过以下两种方法
// Array.from() 将类数组对象或者可遍历对象转换成真正的数组
// 类数组对象最基本的要求是具有length属性的对象
const result = Array.from(new Set(arr))
console.log(result) // [1, 2, 3, 4]

// 扩展运算符
const result = [...new Set(arr)]
console.log(result) // [1, 2, 3, 4]

// 延申知识：1. Array.from()对比扩展运算符，可以传入第二个参数，可以返回集合数据处理后的值
const result = Array.from(new Set(arr), i => i + 1) // 给集合所有数据+1并返回到新的数组
console.log(result) // [2, 3, 4, 5]

// 2. Array.from() 还可以将字符串转换成数组
const str = 'Hello World!'
const result = Array.from(str)
console.log(result) // ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '!']

// 3. 将类对象数组转换成真正的数组
const obj = {
    0: '张三',
    1: 20,
    2: '男',
    'length': 3 // 若不添加'length'属性，则转换成空数组，若不加引号，则转换后元素均为undefined
}
const result = Array.from(obj)
console.log(result) // [ '张三', 20, '男' ]
```



## ES2015 Map

Map 与 Object对象类似，都是键值对的集合，但是Object对象的键只能是字符串，而Map的键可以为任意数据类型

```javascript
// Object中的键
const obj = {}
obj[true] = 'value'
obj[123] = 'value'
obj[{a: 1}] = 'value'
console.log(Reflect.ownKeys(obj)) // [ '123', 'true', '[object Object]' ] 打印出来的键都是字符串类型的

// Map中的键
const m = new Map()
const obj = {name: '张三'}
m.set(obj, 'value')
console.log(m) // Map { { name: '张三' } => 'value' } 键可以为任意数据类型
console.log(m.get(obj)) // value 获取map中的值
console.log(m.has(obj)) // true 判断某个键是否存在
console.log(m.delete(obj)) // true 删除某个键
m.clear() // true 清空map数据结构

m.forEach((value, key) => {
    console.log(value, key) // value { name: '张三' }
})
```



## ES2015 Symbol

一种全新的原始数据类型，每个Symbol都是独一无二的，目前最主要的作用是为对象添加独一无二的属性名

```javascript
const s = Symbol()
console.log(s) // Symbol()
console.log(typeof s) // symbol

console.log(Symbol() === Symbol()) // false 每个Symbol都是不同的

// 可以传入字符串作为标识文本，常用于调试
console.log(Symbol('foo'))
console.log(Symbol('bar'))
console.log(Symbol('baz'))

const obj = {}
obj[Symbol()] = '123'
obj[Symbol()] = '456'
console.log(obj) // { [Symbol()]: '123', [Symbol()]: '456' } 能正常打印

// 为对象添加私有成员，不允许外部直接访问
/*a.js ---------------------------------------------*/
const name = Symbol()
const person = {
    [name]: '张三',
    say () {
        console.log(this[name])
    }
}
/*b.js ---------------------------------------------*/
// 在外部文件无法创建一样的Symbol数据
console.log(person[Symbol()]) // undefined
person.say() // '张三'

// 扩展：目前已有7种数据类型，string,number,null,undefined,boolean,symbol,object
// 今后还会添加新的数据类型 BigInt，用于存储长的数字

// Symbol 补充
console.log(Symbol('foo') === Symbol('foo')) // false 即便有相同的标识符仍然是不相同的

// 要想定义相同的Symbol值，除了使用全局的变量，还可以使用Symbol内置的静态方法
const s1 = Symbol.for('foo')
const s2 = Symbol.for('foo')
console.log(s1 === s2) // true 
// 若传入的值不是字符串类型，则会被转换成字符串类型，所以 Symbol.for(true) === Symbol.for('true') 为 true

// Symbol内置了很多常量，用于内部方法的标识，可以实现很多js内置的接口
// 如果想自定义对象的toString标签
const obj = {}
console.log(obj.toString()) // [object Object]

const obj = {
    [Symbol.toStringTag]: 'XObject'
}
console.log(obj.toString()) // [object XObject]

// Symbol定义的对象属性，无法通过for...in,Object.keys(),JSON.stringify()等方式获取，因此很适合定义对象的私有属性
const obj = {
    [Symbol()]: 'symbol value',
    foo: 'normal value'
}
for(let key in obj){
    console.log(key) // foo
}
console.log(Object.keys(obj)) // [ 'foo' ]
console.log(JSON.stringify(obj)) // {"foo":"normal value"}
// 如果需要获取obj内symbol类型的属性
console.log(Object.getOwnPropertySymbols(obj)) // [ Symbol() ] 获取到的全是对象中symbol类型的属性
console.log(Reflect.ownKeys(obj)) // [ 'foo', Symbol() ] 能获取到包括symbol类型的所有属性
```



## ES2015 for ... of 循环

在ES2015之前，经常使用for遍历普通数组，for..in遍历数组获取数组下标，forEach函数式遍历方法等，这些遍历方式都有一种局限性，因此引用全新的遍历方式 for...of ，作为遍历所有数据结构的统一方式

```javascript
// for...of循环的基本使用
const arr = [100, 200, 300, 400, 500]
for(let item of arr){
    console.log(item) // 100 200 300 400 500 和 for...in 的区别是返回的是数组元素的值，而不是下标
    if(item > 300){
        break
    } // 100 200 300 400 可以取代forEach遍历方式,而且可以随时终止循环，forEach不行
}
// ES2015之前要中止循环，可以使用some()和every()遍历方法
arr.some(item => {
    console.log(item)
    return item > 300
}) // 100 200 300 400 满足返回条件则会中止循环，返回ture，若循环结束后仍未满足返回条件，则返回false
arr.every(item => {
    console.log(item)
    return item < 300
}) // 100 200 300 不满足返回条件后会中止循环，返回false，若循环结束后仍没有不满足返回条件的值，则返回true
// 也可以用find() 和 findIndex() 中止循环
arr.find(item => {
    console.log(item)
    return item > 300
}) // 100 200 300 400 若满足条件，循环中止，返回满足条件的值，若都不满足，则返回undefined
arr.findIndex(item => {
    console.log(item)
    return item > 300
}) // 100 200 300 400 若满足条件，循环中止，返回满足条件的值的下标，若都不满足，则返回-1

// 扩展：forEach() 和 map() 的区别
// forEach()返回都是undefined，map()返回新的数组

// 遍历 Set() 数据结构
const s = new Set(['foo', 'bar', 'baz'])
for (let item of s) {
    console.log(item) // foo bar baz 正常遍历
}

// 遍历 Map() 数据结构
const m = new Map()
m.set('foo', '123')
m.set('bar', '456')
for (let item of m) {
    console.log(item) // [ 'foo', '123' ] [ 'bar', '456' ] 遍历出的是键和值组成的数组
}
for (let [key, value] of m) {
    console.log(key, value) // foo 123   bar 456 可以使用结构获取到键和值
}

// 遍历普通对象
const obj = {
    foo: 123,
    bar: 456
}
for (let item of obj) {
    conosle.log(item) // 报错， 无法遍历
}
```



## ES2015 可迭代接口

ES2015 提供了 Iterable 接口，即可迭代接口，所以实现 Iterable 接口就是 for .. of 的前提

打印可遍历数据类型可以看到共同点，均实现了 Iterable 接口

```javascript
const set = new Set(['foo', 'bar', 'baz'])
const iterator = set[Symbol.iterator]() // 调用set数据结构原型__Proto__上的iterator方法

// 不断遍历数据
console.log(iterator.next()) // { value: 'foo', done: false }
console.log(iterator.next()) // { value: 'bar', done: false }
console.log(iterator.next()) // { value: 'baz', done: false }
console.log(iterator.next()) // { value: undefined, done: true }
```



## ES2015 实现可迭代接口

如果自定义的对象也实现了Iterable接口，那么就可以被 for...of 遍历

```javascript
const obj = { // 自定义对象，实现了Iterable接口，内部有实现了迭代器的iterator方法
	[Symbol.iterator]: function () {
		return { // 实现了迭代器接口 Iterator, 内部有用于迭代的next方法
			next: function () {
				return { // 实现了迭代结果接口 IterationResult, 必须有value属性和done属性
					value: 'foo', // 表示当前被迭代的数据，可以是任意类型
					done: true // 表示迭代是否结束
				}
			}
		}
	}
}
for (let item of obj) {
	console.log('循环体')
}
// 不会报错，说明已经实现了iterable接口，可以被 for...of 遍历了， 但是因为返回了done: true，循环结束了

// 实现自定义对象的Iterable接口
const obj = {
    store: ['foo', 'bar', 'baz'], // 存放需要被迭代的数据
	[Symbol.iterator]: function () {
        let index = 0 // 累加器
        const self = this // next方法内的this对象不止向obj，随意需要存储this
		return {
			next: function () {
				const result =  {
					value: self.store[index],
					done: index >= self.store.length
				}
                index++
                return result
			}
		}
	}
}
for (let item of obj) {
	console.log('循环体', item) // 循环体 foo  循环体 bar  循环体 baz
}
```



## ES2015 迭代器模式

应用案例：

```javascript
// 场景：协同开发一个任务清单应用
/* 接口代码 -------------------------------------------- */
	const obj = {
        life: ['吃饭', '睡觉', '打豆豆'],
        learn: ['语文', '数学', '外语'],
        work: ['上班'],
        [Symbol.iterator]: function () {
            const all = [...this.life, ...this.learn, ...this.work]
            let index = 0
            return {
                next: function () {
                	return {
                		value: all[index],
                		done: index++ >= all.length
            		}
            	}
            }
        }
    }
/* 调用代码 -------------------------------------------- */
    for (let item of obj) {
        console.log(item)
    }
// 迭代器模式核心是提供统一对外遍历接口，让外部不用关心数据结构内部的实现
```



## ES2015 生成器

生成器 Generator 能在复杂的异步代码中减少异步编程中回调嵌套过深的问题，提供更好的异步编程解决方案

```javascript
// 定义生成器函数 function 后面添加 * 号
function * foo () {
    console.log('张三')
    return 100
}
const result = foo()
console.log(result) // Object [Generator] {} 生成器对象
console.log(result.next()) // 生成器函数才开始执行，生成器对象也实现了Iterator接口

// 生成器函数需要配合 yield 关键词使用
function * foo () {
    console.log('11111')
    yield 100 // 不会结束函数，可以继续执行
    console.log('22222')
    yield 200
    console.log('33333')
    yield 300
}
const generator = foo()
console.log(generator.next()) // 11111 {value: 100, done: false} 在yield中断执行
console.log(generator.next()) // 22222 {value: 200, done: false} 在yield中断执行
console.log(generator.next()) // 33333 {value: 300, done: false} 在yield中断执行
console.log(generator.next()) // {value: undefined, done: true} 结束执行
// 总结：生成器函数会自动返回生成器对象，调用对象的next方法才会让函数开始执行，遇到yield关键词，函数的执行会被暂停，而且 ield 后面的值会被做为next的结果返回，继续调用next方法，函数会被继续执行，直到结束，并且返回值的done属性变为true
```

案例应用：

```javascript
// 发号器
function * createIdMaker () {
    let id = 1
    while (true){
        yield id++  // 每次调用next才会执行，不用担心死循环
    }
}
const idMaker = createIdMaker()
console.log(idMaker.next().value)
console.log(idMaker.next().value)
console.log(idMaker.next().value)
console.log(idMaker.next().value)

// 用生成器给对象添加Iterator方法
const obj = {
        life: ['吃饭', '睡觉', '打豆豆'],
        learn: ['语文', '数学', '外语'],
        work: ['上班'],
        [Symbol.iterator]: function * () {
            const all = [...this.life, ...this.learn, ...this.work]
            for (let item of all){
                yield item
            }
        }
    }
for (let item of obj){
    console.log(item)
}
```



## ES2015 ES Modules

语言层面的模块化标准，之后的课程再记录



## ES2016 概述

新增了2个小功能

### Array.prototype.includes

```javascript
const arr = ['foo', 1, NaN, false]
// 在ES2016之前，要判断数组中是否包含某个值，需要借助indexOf判断
console.log(arr.indexOf('foo')) // 0 返回数据在数组中的索引值
console.log(arr.indexOf(1)) // 1 返回数据在数组中的索引值
console.log(arr.indexOf(NaN)) // -1 indexOf无法判断NaN
// ES2016新增了给数组新增了includes属性方法用于判断数组是否包含某个值，返回值是布尔值
console.log(arr.includes('foo')) // true
console.log(arr.includes(1)) // true
console.log(arr.includes(NaN)) // true
```



### 指数运算符

```javascript
// 在ES2016之前，如果要进行指数运算，要借助Math.pow()
console.log(Math.pow(2, 10)) // 1024

// ES2016可以直接使用指数运算符
console.log(2 ** 10) // 1024
```



## ES2017 概述

### Object.values

```javascript
const obj = {
	foo: 'value1',
	bar: 'value2'
}
// 和 Object.keys() 方法类似，但是返回的是对象所有的值组成的数组，而不是键
console.log(Object.values(obj)) // [ 'value1', 'value2' ]
```



### Object.entries

```javascript
// 将普通对象转换成由键值对组成的数组
console.log(Object.entries(obj)) // [ [ 'foo', 'value1' ], [ 'bar', 'value2' ] ]

// 这可以通过for...of遍历普通对象
for (let [key, value] of Object.entries(obj)){
    console.log(key, value) // foo value1   bar value2
}

// Map数据结构需要的也是这种格式的数组，所以可以将对象转换成Map类型的对象
console.log(new Map(Object.entries(obj))) // Map { 'foo' => 'value1', 'bar' => 'value2' }
```



### Object.getOwnPropertyDescriptors

```javascript
// 获取对象的完整描述信息，主要配合ES5新增的get 和 set属性使用
const p1 = {
    firstName: 'Lei',
    lastName: 'Wang',
    get fullName () { // 定义的只读属性，非方法
        return this.firstName + ' ' + this.lastName
    }
}
console.log(p1.fullName) // Lei Wang

const p2 = Object.assign({}, p1)
p2.firstName = 'Li'
console.log(p2.fullName) // Lei Wang 没有变化，因为assign赋值的时候把get静态属性变成普通的属性了

// 使用 getOwnPropertyDescriptors 处理问题
const descriptors = Object.getOwnPropertyDescriptors(p1) // 获取p1的完成描述信息
const p2 = Object.defineProperties({}, descriptors) // 将描述信息添加到空对象
p2.firstName = 'Li'
console.log(p2.fullName) // Li Wang 正常修改
```



### padStart & padEnd

用于将字符串用特定的值补充到特定的位数

```javascript
const books = {
	html: 5,
    css: 16,
    javascript: 128
}

for (let [name, count] of Object.entries(books)){
    console.log(name, count)
    /*
        html 5
        css 16
        javascript 128
    */
}
for (let [name, count] of Object.entries(books)){
    console.log(name.padEnd(16, '-'), '|', count.toString().padStart(3, '0'))
    /*
        html------------ | 005
        css------------- | 016
        javascript------ | 128
    */
}
```



### 在函数参数中添加尾逗号

```javascript
function foo (
	bar,
	baz,
){}
```



# JavaScript 异步编程



## 概述

JS执行环境中负责执行代码的线程只有一个

为了解决单线程执行代码耗时任务阻塞执行的问题，JavaScript 将任务的执行模式分为了两种

* 同步模式（Synchronous）
* 异步模式（Asynchronous）



## 同步模式

```javascript
// 同步执行代码剖析
// 程序开始执行的时候会将所有代码压入全局调用到调用栈执行
console.log('global begin') // 将这条语句压到调用栈执行，执行完毕后，弹出调用栈

function bar () { // 函数声明不会执行，直接进行下一步
	console.log('bar task') // bar函数被执行后，压入调用站执行，完毕后弹出
}

function foo () { // 函数声明不会执行，直接进行下一步
	console.log('foo task') // foo函数被执行后，压入调用栈执行，完毕后弹出
    bar() // foo函数被执行后，压入调用栈执行，完毕后弹出
}

foo() // 将foo函数压入调用栈，调用完毕后弹出

console.log('global end') // 最后压入调用栈执行，完毕后弹出
```



## 异步模式

不会等待任务的结束才开始下一个任务，开启过后就立即往后执行下一个任务，后续逻辑一般会通过回调函数的方式定义

```javascript
// 异步执行代码剖析
// 程序开始执行的时候会将所有代码压入全局调用到调用栈执行
console.log('global begin') // 压栈，出栈

setTimeout(function timer1 () { // 压栈，执行，生成计时器放一边继续执行， 出栈
    console.log('timer1 invoke') // timer2执行完毕出栈后，等待timer1计时完成，压入消息队列，被Event loop 检测到，压入调用栈执行，出栈
}, 1800)

setTimeout(function timer2 () { // 压栈，执行，生成计时器放一边继续执行， 出栈
	console.log('timer2 invoke') // 等计时器完成后压入消息队列，因为只有1s，所以先压入消息队列，Event loop 检测到线程没有任务在执行了，并且消息队列有任务在等待，立即执行消息队列的任务，压入调用栈执行，然后出栈
	
	setTimeout(function inner () { // 压栈，执行，生成计时器放一边继续执行， 出栈
		console.log('inner invoke') // 等待计时完成，压入消息队列，被Event loo检测到，压入调用栈执行，出栈，整个任务结束
	}, 1000)
}, 1000)

console.log('global end') // // 压栈，出栈，线程执行完毕
```

异步模式执行示意图

![异步调用示意图](E:\前端开发工程师的学习之旅\前端进阶学习代码\模块一\任务一 ECMAScript新特性\notes\images\pic_04.png)



## 回调函数

所有异步编程的根基，由调用者定义，交给执行者执行的函数被称为回调函数

```javascript
function foo (callback) {
	setTimeout(function () {
		callback()
	}, 1000)
}

foo(function () {
	console.log('这就是一个回调函数')
	console.log('调用者定义这个函数，执行者执行这个函数')
	console.log('其实就是调用者告诉执行者异步任务结束后应该做什么')
})
```



## Promise 概述

一种更优的异步编程统一方案，直接使用传统回调方式去完成复杂的异步流程，会导致回调地狱的问题。因此CommonJS社区提出了Promise的规范，在ES2015中被标准化，成为语言规范

Promise的状态一旦从Pending变更成失败或者成功之后，状态将不会再次变更



## Promise 的基本用法

```javascript
const promise = new Promise(function (resolve, reject) {
	// resolve(100) // 执行后会触发成功的回调
	reject(new Error('promise rejected!')) // 执行后会触发失败的回调
})

promise.then(function (value) { // 第一个参数执行成功的回调
	console.log('resolved', value)
}, function (error) { // 第二个参数执行失败的回调
	console.log('reject', error)
})
```

应用案例：

```javascript
// promise 方式的 ajax
function ajax (url) {
    return new Promise(function (resolve, reject) {
        let xhr = new XMLHttpRequest() // 定义一个请求
        xhr.open('GET', url) // 定义请求的方式为GET，以及请求地址
        xhr.responseType = 'json' // 定义返回的数据格式
        xhr.onload = function () { // 请求完成后才会执行
            if (this.status === 200) {
                resolve(this.response)
            } else {
                reject(new Error(this.statusText))
            }
        }
        xhr.send() // 开始请求
    })
}
ajax('/api/api.json').then(function (res) { // 成功的回调
    console.log(res)
}, function (error) { // 失败的回调
    console.log(error)
})
```



## Promise 链式调用

* Promise 对象的 then 方法会返回一个全新的 Promise 对象
* 后面的 then 方法就是在为上一个 then 返回的 Promise 注册回调
* 前面的 then 方法中回调函数的返回值会作为后面 then 方法回调的参数
* 如果回调中返回的是 Promise，那后面 then 方法的回调会等待它的结束

```javascript
ajax('/api/api.json')
	.then(function (res) { // 调用结束之后默认返回新的Promise
        console.log(res)
    })
    .then(function (res) {
        console.log(res)
    	return ajax('/api/api.json')
    })
    .then(function (res) { // 这步其实是上一个then方法返回的Promise调用的
        console.log(res)
    	return 'foo'
    })
    .then(function (res) {
        console.log(res) // foo  如果返回的不是Promise，会被当成回调的参数返回
    })
```



## Promise 异常处理

如果在 Promise 中出现了异常，或者手动抛出了异常，会被 reject 回调函数捕获到

```javascript
ajax('/api/api.json')
	.then(function (res) { // 成功的回调
        console.log(res)
    }, function (err) { // 失败的回调，只能捕获当前Promise的异常
        console.log(err)
    })
    .then(undefined, function (err) { // 和catch方法是一样的
    	console.log(err)
    })
    .catch(function (err) { // 通过 catch 方法执行捕获异常后的操作, 能捕获链式调用中所有的异常
    	console.log(err)
    })
```



## Promise 静态方法

### Promise.resolve()

```javascript
// 快速的把一个值转换成Promise对象
Promise.resolve('foo')
	.then(function (res) {
    	console.log(res) // foo
	})

// 如果接收的到的是一个Promise对象，那么会被原样返回
const promise = ajax('/api.json')
const promise1 = Promise.resolve(promise)
console.log(promise === promise1) // true

// 了解，如果传入的是一个对象，并且有then方法，则会被转为原生的Promise对象
Promise.resolve({
    then: function (onFulfilled, onRejected){
        onFulfilled('foo')
    }
})
.then (function (res) {
    console.log(res) // foo
})
```



### Promise.reject()

```javascript
// 无论传入什么参数，都会被做为失败的原因
Promise.reject('anything')
	.catch(function (err) {
    	console.log(err) // anything
	})
```



## Promise 并行执行

### Promise.all()

可以将多个 Promise 对象合并成一个 Promise 统一管理

```javascript
// 接收一个Promise数组
const promise = Promise.all([
    ajax('api/users.json'),
    ajax('api/posts.json')
])

promise.then(res => { // 当所有promise都成功完成才会返回成功的回调
    console.log(res)
})
.catch(err => { // 若有一个promise失败了，则会返回失败的回调
    console.log(err)
})

// 串行和并行组合
ajax('/api/urls.json')
	.then(res => {
    	const urls = Object.values(res)
        const tasks = urls.map(url => ajax(url))
		return Promise.all(tasks)
	})
	.then(res => {
        console.log(res)
    })
```



### Promise.race()

可以将多个 Promise 对象合并成一个 Promise，和 Promise.all()不同的是，会随着所有任务中第一个完成的任务结束

```javascript
// 可用于请求超时
const request = ajax('/api/posts.json')
const timeout = new Promise(function (resolve, reject) {
    setTimeout(() => reject(new Error('timeout')), 500)
})
Promise.race([
    request,
    timeout
])
.then(res => {
    console.log(res)
})
.catch(err => {
    console.log(err)
})
```



## Promise 执行时序

### 微任务

[微任务] 直接在当前任务结束后立即执行

Promise 的回调会作为微任务执行

Promise & MutationObserver  // 监听DOM结构变化

node 中 process.nextTick

会作为微任务直接在本轮任务的末尾执行

### 宏任务

回调队列中任务被称之为 [宏任务]

目前绝大多数异步调用都是作为宏任务执行



## Generator 异步方案

```javascript
// Generator 生成器
function * foo () {
    try {
        console.log('start')
        const res = yield 'foo' // 调用next方法会在yield关键字中断并返回值 {value: 'foo', done: false}
        console.log(res) // bar
    } catch (e) {
        console.log(e) // 捕获异常
    }
    
}
const generator = foo() // 并不会立即执行
const result = generator.next() // 可以拿到因为yield中断返回的值
console.log(result) // {value: 'foo', done: false}
generator.next('bar') // 传入参数的话，会作为 yield 语句的返回值
generator.throw(new Error('Generator error')) // 手动抛出异常

// 生成器异步方案
function * main () {
    try {
        const res = yield ajax('/api/user.json')
        console.log(res)
        const res2 = yield ajax('/api/user.json')
        console.log(res2)
        const res3 = yield ajax('/api/user.json')
        console.log(res3)
    }catch (err){
        console.log(err)
    }
}
const g = main() // 函数调用返回生成器对象，此时函数还没执行
const result = g.next() // 执行函数，在第一个yield中断，返回{value: ajax的Promise对象, done: false}
result.value.then(data => { // 执行返回的对象value的Promise的then方法
    const result2 = g.next(data) // ajax返回的resolve值当作参数重新传给main生成器，返回值赋值
    result2.value.then(data => {
        const result3 = g.next(data)
        result3.value.then(data => {
            g.next(data)
        })
    })
})
// 这种生成器含有函数嵌套，可以用递归优化

// 递归执行Generator生成器
function co (generator){ // 封装成生成器函数
    const g = generator()
    function handleResult (result) {
        if(result.done === true) return
        result.value.then(data = > {
            const res = g.next(data)
            handleResult(res)
        }, err => {
            g.throw(err) // 捕获异常
        })
    }
    handleResult(g.next())
}
co(main)
```



## Async 函数

Async / Await 语法糖，语言层面的异步编程标准

```javascript
async function main () {
    try {
        const res = await ajax('/api/user.json')
        console.log(res)
        const res2 = await ajax('/api/user.json')
        console.log(res2)
        const res3 = await ajax('/api/user.json')
        console.log(res3)
    }catch (err){
        console.log(err)
    }
}
const promise = main() // Async函数会返回Promise对象
promisr.then(() => {
    console.log('all completed')
})
// await目前只能在async函数内使用
```



# TypeScript 语言

## 概述

解决 JavaScript 类型系统的问题，大大提高代码的可靠程度



## 强类型与弱类型

* 强类型与弱类型（类型安全）
* 静态类型与动态类型（类型检查）



<strong>强类型</strong>：语言层面限制函数的实参类型必须与形参类型相同（强类型不允许任意的隐式类型转换）

<strong>弱类型:</strong>  语言层面不会限制实参的类型（弱类型允许任意的数据隐式类型转换）

强类型有更强的类型约束，而弱类型中几乎没有什么约束

变量类型允许随时改变的特点，不是强弱类型的差异



## 静态类型和动态类型

* <strong>静态类型：</strong> 一个变量声明时它的类型就是明确的，声明过后，它的类型就不允许再修改
* <b>动态类型：</b> 运行阶段才能够明确变量类型，而且变量的类型随时可以改变

<b>动态类型</b>语言中的变量没有类型，变量中存放的值是有类型的

常见的编程语言这两个角度下的表现

![常见的编程语言](E:\前端开发工程师的学习之旅\前端进阶学习代码\模块一\任务一 ECMAScript新特性\notes\images\pic_05.png)



## 弱类型的问题

```javascript
// 在开发过程中，一些问题很难发现，往往只有在生产环境中才发现问题
const obj = {}
// obj.foo()
setTimeout(() => {
    obj.foo()
}, 1000000) // 这种问题才测试的时候比较难发现

// 因为有隐式转换，所以在数字运算的时候有时候会达不到预期的效果
function (a, b) {
    return a + b
}
console.log(function(100, 100)) // 200
console.log(function(100, '100')) // 100100

const obj = {}
obj[true] = 100
console.log(obj('true')) // 100 因为有隐式转换成字符串，所以这样也能拿到值
```



## 强类型的优势

1. 错误更早暴露
2. 代码更智能，编码更准确
3. 重构更可靠
4. 减少不必要的类型判断



## Flow概述

JavaScript 的类型检查器



## Flow 快速上手

>安装：
>
>yarn -init // 初始化项目
>
>yarn add flow-bin --dev // 安装flow到开发环境

```javascript
// @flow 必须要文件头声明使用flow插件
function sum (a: number, b: number) { // vs code自带的代码校验会报错，可根据javascript validate关闭
    return a + b
}
sum(100, 100)
sum('100', '100')
```

>yarn flow init // 初始化flow
>
>yarn flow // 执行flow命令



## 编译移除注解

方案一：

	>通过官方插件 flow-remove-types
	>
	>yarn add flow-remove-types --dev
	>
	>yarn flow-remove-types . (需要编译的目录) -d dist(输出的目录)



方案二：

>通过Babel插件进行移除
>
>yarn add @babel/core @babel/cli @babel/preset-flow --dev
>
>配置Babel
>
>新建 .babelrc 文件
>
>{
>
>​	“presets”: ["@babel/preset-flow"]
>
>}
>
>yarn babel src -d dist



## Flow 开发工具插件

vs code可安装插件 Flow Language Support 用于直接查看类型检查的错误，而不用编译后才能查看

需要保存后才能看到效果



## Flow 类型推断

```javascript
// @flow
function square (n) {
    return n * n // 即便参数没有代码检查，这里仍然会报错，这种情况叫类型推断
}
square('100')
```



## Flow 类型注解

```javascript
// @flow
function square (n: number) {
    return n * n
}
let num: number = 100 // 给变量添加注解
function foo(): number { // 给函数添加注解，如果没有返回值会报错
    return 100
}
function foo(): void { // 如果函数没有返回值，则返回undefined，注解要用void
   
}
```



## Flow 原始类型

```javascript
// @flow
const a: string = 'foobar'
const b: number = Infinity // NaN // 100
const c: boolean = false // true
const d: null = null
const e: void = undefined
const f: symbol = Symbol()
```



## Flow 数组类型

```javascript
// @flow
const arr1: Array<number> = [1, 2, 3]
const arr2: number[] = [1, 2, 3] // 数组类型检查的两种方式

// 元组
const foo: [number, string] = [100, 'foo'] // 设置固定长度的数组
```



## Flow 对象类型

```javascript
// @flow
const obj1: {foo: string, bar: number} = {foo: 'string', bar: 100} // 对象类型的检查
const obj2: {foo?: string, bar: number} = {bar: 100} // 如果键后面有？,表示属性可选
const obj3: { [string]: string } = {} // 可以设置对象键和值的类型检查
obj3.key1 = 'value1'
obj3.key2 = 'value2'
```



## Flow 函数类型

```javascript
// @flow
function foo (callback: (string, number) => void) { // 设定回调函数的参数和返回值的类型检查
    callback('string', 100)
}
foo(function (str, num) {
    // str => string
    // num => number
})
```



## Flow 特殊类型

```javascript
// @flow
const a: 'foo' = 'foo' // 只能传字符串foo
const type: 'success' | 'warning' | 'danger' = 'success' // 只能传限制的字符串
type StringOrNumber = string | number // 可以用type关键字定义联合类型
const b: StringOrNumber = 'string'

const gender: ?number = undefined // maybe类型 相当于 number | null | void
```



## Flow Mixed & Any

```javascript
// @flow
function passMixed (value: mixed) { // 可以看作所有类型的集合
    if (typeof value === 'string'){ // 和any不同的是需要确认具体的类型之后才能使用相应的内置方法
        value.substr(1)
    }
    if (typeof value === 'number'){
        value * value
    }
}
passMixed('string')
passMixed(100)

function passAny (value: any) { // 可以看作所有类型的集合
    value.substr() // 弱类型，不会报错
    value * value
}
passAny('string')
passAny(100)
```



## Flow 类型小结

Flow 官网 ： [https://flow.org/en/docs/types/](https://flow.org/en/docs/types/)

第三方类型手册：[https://www.saltycrane.com/cheat-sheets/flow-type/latest/](https://www.saltycrane.com/cheat-sheets/flow-type/latest/)



## Flow 运行环境 API

flow提供了对运行环境API的支持，以下提供相应的文档进行查阅

- [https://github.com/facebook/flow/blob/master/lib/core.js](https://github.com/facebook/flow/blob/master/lib/core.js)
- [https://github.com/facebook/flow/blob/master/lib/dom.js](https://github.com/facebook/flow/blob/master/lib//dom.js)
- [https://github.com/facebook/flow/blob/master/lib/bom.js](https://github.com/facebook/flow/blob/master/lib/bom.js)
- [https://github.com/facebook/flow/blob/master/lib/cssom.js](https://github.com/facebook/flow/blob/master/lib/)
- [https://github.com/facebook/flow/blob/master/lib/node.js](https://github.com/facebook/flow/blob/master/lib/node.js)



## TypeSctipy 概述

JavaScript 的超集

![TypeScript示意图](E:\前端开发工程师的学习之旅\前端进阶学习代码\模块一\任务一 ECMAScript新特性\notes\images\pic_06.png)

TypeScript 可以将ECMAScript的新特性最高编译成支持es3的代码

任何一种JavaScript运行环境都支持

TypeScript ——前端领域中第二语言

缺点一：语言本身多了很多概念

缺点二： 项目初期，TypeScript会增加一些成本



## TypeScript 快速上手

>yarn init // 初始化项目
>
>yarn add typescript --dev // 在开发环境安装typescript
>
>新建ts文件，后缀名是.ts

```javascript
// 可以完全按照 JavaScript 标准语法编写代码
const hello = (name: string) => { // 和Flow一样进行类型检查
    console.log(`Hello, ${name}`)
}
hello('TypeScript')
```

>yarn tsc 文件名
>
>编译后会自动清除类型检查



## TypeScript 配置文件

>yarn tsc --init // 初始化typescript
>
>会生成 tsconfig.json 配置文件

```javascript
// 配置文件常用参数
{
  "compilerOptions": {
    "target": "es5",  // 设置要转成的ECMAScript版本
    "module": "commonjs",  // 输出的代码会采用什么方式进行模块化
    "lib": ["ES2015", "DOM"], // 设置标准库声明
    "sourceMap": true, // 开启源代码映射，能用souceMap调试ts源代码
    "outDir": "dist", // 设置编译结果输出到的文件夹
    "rootDir": "src", // 设置源代码所在的目录
    "strict": true, // 开启所有严格检查
    "strictNullChecks": true, // 单独设置是否检查类型为null的情况
    "esModuleInterop": true, 
    "skipLibCheck": true,  
    "forceConsistentCasingInFileNames": true 
  }
}
```

>yarn tsc // 直接运行才会按照配置文件编译



## TypeScript 原始类型

```javascript
// 原始数据类型
const a: string = 'foobar'
const b: number = 100
const c: boolean = false
const d: string = null // 在非严格模式下可以为null
const e: void = undefined // 在非严格模式下可以为null
const f: null = null
const g: undefined = undefined
const h: symbol = Symbol() // 如果配置文件target配置的是es5，会报错，因为标准库声明是es5的，并没有symbol的声明
```



## TypeScript 标准库声明

标准库就是内置对象所对应的声明

可以通过配置文件的lib进行设置



## TypeScript 中文错误消息

>yarn tsc --locale zh-CN
>
>可以设置编译信息错误提示为中文

要设置vs code提示错误消息为中文，可以在 setting 搜索 typescript locale 设置为 zh-CN



## TypeScript 作用域问题

在两个不同的ts文件下的全局作用域内定义相同的变量，会造成冲突，

可以使用立即执行函数创建作用域 (function () {const a = 123}) ()

或者使用export {} 创建模块作用域



## TypeScript Object 类型

```javascript
// Object 类型
export {} // 确保跟其他示例没有成员冲突
const foo: object = function () {} // [] // {} 不只是普通对象类型
const obj: {foo: string, bar: number} = {foo: 'string', bar: 100} // 定义普通类型对象，这种方式要和定义的类型检查完全一样，不然会报错
```



## TypeScript 数组类型

```javascript
// 数组类型
const arr1: Array<number> = [1, 2, 3]
const arr2: number[] = [1, 2, 3]
// 案例
function sum (...args: number[]) {
    return args.reduce((prev, current) => prev + current,0)
}
sum(1, 2, 3, 'foo') // 会报错，因为传入了非number数据
```



## TypeScript 元组类型

```javascript
// 元组类型
const tuple: [number, string] = [10, '张三'] // 不能输入不相符的数据类型，不能超过或少于定义的长度
```



## TypeScript 枚举类型

```javascript
// 枚举
enum PostStatus = { // 键值用等号匹配，如果没有指定值，默认从0开始累加
    Draft = 0,
    Unpublished = 1,
    Published = 2
}
enum StringEnum = { // 字符串枚举每个都需要初始化明确的值值
    foo = 'a',
    bar = 'b',
    baz = 'c'
}
const post = {
    title: 'Hello TypeScript',
    content: 'TypeScript is a typed superset of JavaScript',
    status: PostStatus.Draft
}
```

枚举会入侵到运行时的代码，影响编译后的结果

```javascript
// 上述代码编译后呈现
var PostStatus;
(function (PostStatus) {
    PostStatus[PostStatus['Draft'] = 0] = 'Draft'
    PostStatus[PostStatus['Unpublished'] = 1] = 'Unpublished'
    PostStatus[PostStatus['Published'] = 0] = 'Published'
})(PostStatus || (PostStatus = {}))

// 如果确定不会用到索引器，可以使用常量枚举
const enum PostStatus = {
    Draft = 0,
    Unpublished = 1,
    Published = 2
}
```



## TypeScript 函数类型

```javascript
// 函数类型
// 函数声明
function func1 (a: number, b: number):string {
    return 'string'
}
func1(100, 200) // 只能传入的对应数据类型和参数个数
func1(100) // 个数不匹配，报错
func1(100, 200, 300) // 个数不匹配，报错

function func2 (a: number, b?: number):string {
    return 'string'
}
function func3 (a: number, b: number = 100): string {
    return 'string'
}
// 可以通过 ？ 或者 参数默认值的方式，定义可选参数
function func4 (a: number, b: number, ...rest: number[]):string {
    return 'string'
}
// 可以用rest运算符表示其他参数的集合

// 函数表达式
const func5: (a: number, b: number) => string = function (a: number, b: number): string {
    return 'string'
}
```



## TypeScript 任意类型

```javascript
// 任意类型
function foo (value: any) { // 可以传入任意类型的值，ts不会对此做任何检查，不安全
    return JSON.stringify(value) // 序列化成json格式对象，接收任意类型的值
}
```



## TypeScript 隐式类型推断

```javascript
// 类型推断
let age = 18 // 默认会被判断成number数据类型
age = 'string' // 重新赋值其他数据类型会报错

let foo // 若没有办法推断是什么类型的，会被定为any
// 建议为每个变量添加明确的类型
```



## TypeScript 类型断言

```javascript
// 类型断言
const num = [100, 200, 300, 400]
const res = num.find(i => i > 1)  // res的数据类型被判断为 number | undefined
const num1 = res * res // 所以会报错
const num2 = res as number // 方法一，用 as 语法， 不能用number和undefined之外的数据类型，会报错
const num3 = <number>res // 方法二，这种方法在JSX下不能使用
```



## TypeScript 接口

Interfaces 用于约定对象的接口

```javascript
// interfaces
interface Post { // 成员之间可以加逗号，更规范的是加分号，但是可以省略
    title: string
    content: string
    subtitle?: string // 添加 ? 表示可选属性
    readonly summary: string // 添加 readonly 关键字表示只读属性，当初始化后，值不能修改
}

function printPost (post: Post) {
    console.log(post.title)
    console.log(post.content)
}

printPost({ // 必须传入对应的成员
    title: 'Hello TypeScript',
    content: 'A JavaScript superset'
})

interface Cache { // 动态成员，可以添加任意的string成员
    [key: string]: string // key可以为任意的名称
}
const cache: Cache = {}
cache.foo = 'value1'
cache.bar = 'value2'
```



## TypeScript 类的基本使用

```javascript
// 类
class Person {
    name: string // 在ts的类中，需要先定义属性
    age: number
    
   	constructor (name: string, age: number) {
        this.name = name
        this.age = age // 并且一定要赋初值
    }
	sayHi (msg: string): void {
        console.log(`I am ${this.name}, ${msg}`)
    }
}
```



## TypeScript 类的访问修饰符

修饰符有三种public, private, protected

```javascript
// 访问修饰符
class Person {
    public name: string // 默认的都是public修饰符
    private age: number // 私有属性修饰符
    protected gender: boolean // 受保护的属性修饰符
    
   	constructor (name: string, age: number) {
        this.name = name
        this.age = age // 并且一定要赋初值
        this.gender = true
    }
}
class Student extends Person {
    private constructor (name: string, age: number) { // 如果被定义为私有属性，则不能被实例化
        super(name, age)
        console.log(this.gender) // 受保护的属性可以继承
    }
    
    static create (name: string, age: number) { // 可以定义静态方法来返回类的实例，因为还在类的内部，所以可以实例对象，因为可以调用构造器
        return new Person(name. age)
    }
}
```



## TypeScript 类的只读属性

```javascript
class Person {
    public name: string
    private age: number
    protected readonly gender: boolean // 如果有访问修饰符了，应该在后面添加，只读属性无法在外部赋值
    
   	constructor (name: string, age: number) {
        this.name = name
        this.age = age 
        this.gender = true
    }
}
```



## TypeScript 类与接口

```javascript
interface Eat { // 定义类的方法接口，可以写在一起，但是最好一个接口对应一个方法
    eat (food: string) void
}

interface Run {
    run (distance: number) void
}

class Person implements Eat,Run { // 多个不同的接口可以用逗号分割
    eat (food: string): void {
        console.log(food)
    }
	run (distance: number): void {
        console.log(distance)
    }
}

class Animal implements Eat,run {
    eat (food: string): void {
        console.log(food)
    }
	run (distance: number): void {
        console.log(distance)
    }
}
```



## TypeScript 抽象类

```javascript
abstract class Animal { // 前面加上 abstract 之后表示抽象类，只能被继承，无法 new 实例对象
    eat (food: string): void { // 父类的实例方法
        console.log(food)
    }

	abstract run (distance: number): void // 定义抽象方法 
}
    
class Dog extends Animal {
    run (distance: number): void {
        console.log(distance) // 父类定义抽象方法后，必须要子类定义具体的实现
    }
}
// 定义的子类就可以实现父类的实例方法和抽象方法了
const d = new Dog()
d.eat()
d.run()
```



## TypeScript 泛型

泛型指的是声明的时候不指定类型，用的时候才指定类型的一种特征，为了极大程度的复用代码

```javascript
// 泛型
function createNumberArray (length: number, value: number): number[] {
    const arr = Array<number>(length).fill(value) // 内置函数Array内置了泛型，可以通过 <> 来明确传入数据的类型
    return arr
}

// 在ts中，我们可以给函数添加泛型，把类型当成参数，在调用的时候传递类型
function createArray<T> (length: number, value: T): T[] {
    const arr = Array<T>(length).fill(value)
}
```



## TypeSript 类型声明

在引入第三方模块的时候，往往不清楚模块内的函数的声明情况，有时候就需要手动申明

```javascript
import { camelCase } from 'lodash'
// declare 类型声明关键字
declare function camelCase (input: string): string

const res = camelCase('Hello World')
```

现在很多模块内置了类型声明文件，以 .d.ts 结尾的文件，有了类型声明文件之后，就不需要用 declare 关键字手动声明了











































































